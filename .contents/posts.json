[{"title":"ExpoのOTA updateの仕様について","contentSnippet":"この記事は React Native アドベントカレンダーの24日目の記事です。ExpoのOTA updateの仕様が分かりづらく，はまりどころが多いので，注意点や自分でアレンジする方法をまとめました。OTA updateとはOver The Air updateの略。App Store(またはGoogle Play)からアップデートしなくても最新のバージョンに更新できます。審査を通す必要がないので素早く最新のバージョンをユーザーに届けることができます。OTA updateのやりかた                      $ expo publish    ...","link":"https://zenn.dev/marin_a___/articles/7eec197a8c3579","isoDate":"2020-12-24T03:33:21.000Z","dateMiliSeconds":1608780801000,"authorName":"marina"},{"title":"Apollo Client × codegen でのLocalStateの使い方","contentSnippet":"この記事は GraphQL Advent Calendar 2020 19日目の記事です。@policeman-kh さんの GraphQLサーバーをJavaで実装してみる でした。Apollo ClientのLocal Stateとは公式ドキュメントローカルのデータをApollo Clientに保持しておくことができる仕組みです。GraphAPIからデータを取得する際に，同時にローカルのデータも取得することができるというメリットがあります。また，Reduxなどの状態管理ライブラリの代替的な役割としても使用できます。やりたいこと以下のようなDBが既に存在するとします。今回，users.idをactiveUserIdとしてLocal Stateに保持する方法を考えます。今回使用した環境ReactApollo ClientGraphQL Code Generatorhasuraqueryやmutationは既に動く状態で，Local Stateを追加することを想定します。補足：hasuraとはPostgreSQLからGraphQL APIサーバーを自動で構築してくれるものです。Postgreのデータベースに格納したデータに対してGraphQLのクエリが発行できるようになります。codegenの設定公式ドキュメントcodegen.jsmodule.exports = {  schema: [      \"http://localhost:8080/v1/graphql\",      \"src/graphql/local-schema.graphql\", //追加  ],https://github.com/marina-ki/apollo-client_local-state/blob/main/packages/web/codegen.jsclient-side schemaの書き方client-side schemaに以下のように書くことでactiveUserIdというフィールドをqueryに追加することができます。src/graphql/local-schema.graphqlextend type Query {  activeUserId: Int!}これを以下のように使用することができます。src/graphql/queries/MyArticles.graphqlquery MyArticles($id: Int!) {  activeUserId @client @export(as: \"id\")  user: users_by_pk(id: $id) {    id    name    articles {      id      body    }  }}@clientの箇所は，「キャッシュされているactiveUserIdを使用する」ということです。@export(as: \"id\")によって，activeUserIdを$idとしてusers_by_pkの引数に渡すことができます。その結果，useQueryを使うときにわざわざactiveUserIdを渡す必要がなくなります。const { data } = useMyArticlesQuery();また，console.log(data?.activeUserId);という形でキャッシュされたactiveUserIdを取得することもできます。※hasuraでの注意点hasuraでは上記のlocal-schema.graphqlの書き方ではエラーが出ます。 AggregateError:         GraphQLDocumentError: Cannot query field \"activeUserId\" on type \"query_root\".extend type Queryの代わりに以下のように書くことで解決しました。src/graphql/local-schema.graphqltype query_root {  activeUserId: Int!}Local Stateの値を操作するclient.writeQueryを利用します。    await client.writeQuery({      query: MyArticlesDocument,      data: { activeUserId: 1 },    });とすることで，MyArticles queryのacitveUserIdを1に書き換えることができます。注意点として，今回はquery単位でのキャッシュフィールド単位でのキャッシュの両方更新されるので，他のqueryでactiveUserIdを使用している場合，そちらのキャッシュも自動的に更新されます。(キャッシュについてはGraphQL Advent Calendar 2020 2日目で詳しく触れているのでぜひ参考にしてください。)補足以前はclient.writeData(またはcache.writeData)というメソッドがありました。しかし，公式にある通り，v3.0で廃止されています。client|cache.writeData have been fully removed. client|cache.writeQuery, client|cache.writeFragment, and/or cache.modify can be used to update the cache.PRによると，cache.writeDataを呼ぶと全てのqueryを実行し直すため，非効率的だったそうです。まとめReduxなどを使わずに，Apolloだけでremoteのデータもlocalのデータも一元管理することを目的としてLocal Stateが導入されたそうです。https://www.apollographql.com/blog/the-future-of-state-management-dd410864cae2/)Historically, Apollo users managed that 20% in a separate Redux or MobX store. This was a doable solution for Apollo Client 1.0, but when Apollo Client 2.0 migrated away from Redux, syncing local and remote data between two stores became trickier. We often heard from our users that they wanted to encapsulate all of their application’s state inside Apollo Client and maintain one source of truth.今回は「activeUserIdをLocalStateにいれることでqueryを簡単に使用できるようにする」という目的で使ってみましたが，もし単に状態管理をしたいだけであれば，Apollo Client v3.0での新機能のreactive variablesを使うのが良さそうです。使ってみたらまた記事に書こうと思っています。","link":"https://qiita.com/marin_a__/items/9f47bf04ddc44aec4247","isoDate":"2020-12-19T15:39:48.000Z","dateMiliSeconds":1608392388000,"authorName":"marina"},{"title":"TypeScript: 配列の長さを宣言する","contentSnippet":"やりたいことconst numbers = [1, 2, 4, 5] as constconst foo = ['f', 'o', 'o'] as constlet numbers_len1: Length<typeof numbers> = 4; //OKlet numbers_len2: Length<typeof numbers> = 5; //エラーlet foo_len1: Length<typeof numbers> = 3; //OKlet foo_len2: Length<typeof numbers> = 4; //エラーとなるように，配列の長さを宣言するLength typeを作りたい。結論解決法１type Length<T extends ReadonlyArray<any>> = T['length']解決法２type Length<T extends readonly any[]> = T['length']解決法３type Length<T extends any> = T extends { length : infer R } ? R : never;解説すべてGenericsを使っています。https://qiita.com/uhyo/items/e2fdef2d3236b9bfe74a#%E3%82%B8%E3%82%A7%E3%83%8D%E3%83%AA%E3%82%AF%E3%82%B9解決法１type Length<T extends ReadonlyArray<any>> = T['length']ReadonlyArrayという型がTypeScriptに用意されています。The ReadonlyArray type describes Arrays that can only be read fromfunction foo(arr: ReadonlyArray<string>) {  arr.slice(); // okay  arr.push(\"hello!\"); // error!}名前の通り，配列を変更するようなメソッドは使えませんが，今回のようにlengthを取得することはできます。解決法２type Length<T extends readonly any[]> = T['length']解決法１とほぼ同じです。今回は配列をas constでreadonlyとしているので，type Length<T extends any[]> = T['length'] The type 'readonly [1, 2, 4, 5]' is 'readonly' and cannot be assigned to the mutable type 'any[]'.解決法３type Length<T extends any> = T extends { length : infer R } ? R : never;inferについてはこちらの記事が分かりやすいです。T.lengthが存在する場合はそのlengthを返し，存在しない場合はneverを返しています。補足TypeChallengeというサイトに問題がたくさん載っていて，その中のLength of Tupleという問題になっています。上記以外にもたくさん解答があるので参考にしてください。https://github.com/type-challenges/type-challenges/issues?q=label%3A18+label%3Aanswer","link":"https://qiita.com/marin_a__/items/74e087e8952dc78fe13e","isoDate":"2020-11-29T15:19:05.000Z","dateMiliSeconds":1606663145000,"authorName":"marina"}]
