[
  {
    "title": "TypeScript：空オブジェクト用の型をつくりたい",
    "contentSnippet": "やりたいことconst a: EmptyObject = {} //OKconst b: EmptyObject = {hoge: \"aaa\"} //NGconst c: EmptyObject = \"hoge\" //NGとなるようなEmptyObject型を作成したい。結論type EmptyObject = {[key: string]: never}NG例type EmptyObject = {}これだとconst a: EmptyObject = {} //OKconst b: EmptyObject = {hoge: \"aaa\"} //OKconst c: EmptyObject = \"hoge\" //OKになってしまいます。理由としては、{}は特殊な型で、nullとundefined以外を許容してしまうからです。補足：{}の型について{}がnullとundefined以外を許容してしまうのは、JavaScriptはプリミティブに対してもプロパティアクセスができることが関係しています。例えば、string型には.lengthというプロパティがあるので、type StringObject = {    length: number;}const hoge: StringObject = \"a\"ということができます。number型も同様にtype NumberObject = {   toString(): void;}const hoge: NumberObject = 1ということができます。つまり、{}だけではstringの可能性もnumberの可能性も捨てきれないことになり、許容しているということになります。",
    "link": "https://qiita.com/marin_a__/items/992b0c6bcec8ffc74347",
    "isoDate": "2021-02-27T01:27:30.000Z",
    "dateMiliSeconds": 1614389250000,
    "sourceType": "qiita"
  },
  {
    "title": "TypeScript：関数の引数に同じ長さの配列を渡したい",
    "contentSnippet": "やりたいことrequireTwoSameLengthArrays([1, 2], [3, 4]); // okrequireTwoSameLengthArrays([1, 2], [3]); // 型エラーrequireTwoSameLengthArrays([1, 2], [3, 4, 5]); // 型エラーになるような関数を作りたい結論function requireTwoSameLengthArrays<    T extends (readonly [] | readonly any[]) & (        number extends T[\"length\"] ? readonly [] : unknown    )>(t: T, u: { [K in keyof T]: any }){//}ステップ１：最低限の解答function requireTwoSameLengthArrays<    T extends [] | any[]>(t: T, u: { [K in keyof T]: any }) {   //}解説T extends [] | any[]の箇所について。any[]は[]も内包しているのでT extends any[]だけでいいのではないか？と思うかも知れませんが，これはコンパイラーに固定長のタプル型として認識させるために両方必要です。ジェネリクスの配列・タプルの例function func1<T extends any[]>(arg: T) {  return arg;}const a = func1([1,2,3]) //a: number[]const b = func1([1,2,3] as const) //エラー: The type 'readonly [1, 2, 3]' is 'readonly' and cannot be assigned to the mutable type 'any[]'.function func2<T extends  readonly any[]>(arg: T) {  return arg;}const c = func2([1,2,3]) //c: number[]const d = func2([1,2,3] as const) //d: readonly [1, 2, 3]function func3<T extends any[] | []>(arg: T) {  return arg;}const e = func3([1,2,3]) //e: [number, number, number]そのため，１つ目の引数tに[1,2]が入ると，Tは[number,number]であると推論されます。u: { [K in keyof T]: any }はmapped typeと呼ばれますが，Tに配列を入れると少し変わった挙動をして(Mapped Tuple Typeと呼ばれます)，uはTの配列長と同じ(今回の場合は配列長２)のany[]型となります。Mapped Tuple Typeについて詳しく公式の記事はこちらhttps://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-1.html以下の例のように，１つ１つの要素に対してマッピングされ，新しいタプルや配列を生成します。type MapToPromise<T> = { [K in keyof T]: Promise<T[K]> };type Coordinate = [number, number];type PromiseCoordinate = MapToPromise<Coordinate>; // [Promise<number>, Promise<number>]そこで，今回使われているようにconst a: {[K in keyof [number,number]]: string}としたときのaの型を見てみると，以下のように配列長が２のstring[]型になっていることが確認できます。const a: {    [x: number]: string;    0: string;    1: string;    length: string;    toString: string;    toLocaleString: string;    pop: string;    push: string;    concat: string;    join: string;    reverse: string;    shift: string;    slice: string;    sort: string;    ... 20 more ...;    flat: string;}ステップ２：さらに拡張性のある解答今のままだと以下のときにエラーが発生します。requireTwoSameLengthArrays([1, 2] as const, [3, 4]);  //エラー：The type 'readonly [1, 2]' is 'readonly' and cannot be assigned to the mutable type 'any[]'.以下のように改善するとエラーが発生しなくなります。function requireTwoSameLengthArrays<    T extends readonly [] | readonly any[]>(t: T, u: { [K in keyof T]: any }) {   //}ステップ３：さらにさらに拡張性のある解答今のままでは以下のような問題があります。const arr = [1, 2];requireTwoSameLengthArrays(arr, [1, 2, 3]); //型エラーが起きてほしいのに起きない！！！！！！！これはconst arr = [1, 2];の時点でarrがnumber[]と推測されてしまっているからです。以下のように改善すると期待通りの挙動になります。function requireTwoSameLengthArrays<    T extends (readonly [] | readonly any[]) & (        number extends T[\"length\"] ? readonly [] : unknown    )>(t: T, u: { [K in keyof T]: any }){//}これを使うと以下のような挙動をします。const arr = [1, 2];requireTwoSameLengthArrays(arr, [1, 2, 3]);// エラー：Argument of type 'number[]' is not assignable to parameter of type '(readonly any[] | readonly []) & readonly []'.const arr = [1, 2] as const;requireTwoSameLengthArrays(arr, [1, 2, 3]); // エラー：Argument of type '[number, number, number]' is not assignable to parameter of type 'readonly [any, any]'.const arr = [1, 2, 5] as const;requireTwoSameLengthArrays(arr, [1, 2, 3]); //ok解説TがT[\"length\"]を持っているかどうかをチェックして、もしT[\"length\"]がnumberであれば空のタプルを要求することでエラーを発生させています。参考",
    "link": "https://qiita.com/marin_a__/items/f2c6ef4e73fdabf607a2",
    "isoDate": "2021-01-25T13:44:02.000Z",
    "dateMiliSeconds": 1611582242000,
    "sourceType": "qiita"
  },
  {
    "title": "Blitz.jsの議論から学ぶ，formik vs react-final-form vs react-hook-form",
    "contentSnippet": "What should the default form library be in Blitz apps?BlitzがどのFormライブラリをデフォルトにするかの議論が参考になったので要約しました。formikreact-final-formreact-hook-formの３択で，結論としては，React Final Formを推奨とする形に落ち着きました。最初のコメントBlitz.jsの作者であるBrandon(@flybayer)さんがコメントしています。要約するとこんな感じ。Formik以前使ってたけど，パフォーマンスめっちゃ悪いって気づいたから，Formikは無しで。React-final-form最近ずっと使ってるけどいい感じ。React-hook-formほとんど使ったことない。React-final-formをReact-hook-formに書き換えてみたが，コードの複雑さとしてはそこまで差異はない。https://github.com/blitz-js/blitz/pull/767/files議論全体的にFormikは無いよねという感じでした。気になった意見をpick upします。react-hook-formのデメリット対象のコメント→ https://github.com/blitz-js/blitz/discussions/768#discussioncomment-39148別のFormライブラリとの互換性の低さMaterialUIなどのサードパーティー製のコンポーネントと一緒に使う場合は<Controller>コンポーネントでwrapしなくてはいけない。      <Controller        name=\"iceCreamType\"        as={Select}        options={[          { value: \"chocolate\", label: \"Chocolate\" },          { value: \"strawberry\", label: \"Strawberry\" },          { value: \"vanilla\", label: \"Vanilla\" }        ]}        control={control}        rules={{ required: true }}      /><Controller>を使わないパターンと使うパターンの２つの異なるAPIを知っておかなくてはいけない。一方，react-final-formはuseField()というAPIだけで済むので，他のライブラリとの互換性が高い。refの渡し方が不自然focusしたときに何かを発動したいときなどはrefを自分で渡すことになるが，そのときのrefの渡し方が面倒くさい。  const { register, handleSubmit } = useForm();  const firstNameRef = useRef();  const onSubmit = data => console.log(data);  return (    <form onSubmit={handleSubmit(onSubmit)}>      <input name=\"firstName\" ref={(e) => {        register(e)              // hook-form register        firstNameRef.current = e // manually assign your ref      }} />ref={ref}で渡したいのに…。react-final-formのデメリットrender propsが初心者には難しいのではないか？というコメントがいくつかあった。基本的にrender propsを使うreact-final-formformik基本的にrender propsを使わないreact-hook-formそれに対し，Brandonさんは以下のように反論しています。there is only one top level render prop with final-form which also provides the form context.トップ層でしか使用していないし，So either way, you'll likely have a render prop. I definitely agree the primary API shouldn't be a render prop, but looks like it's impossible to 100% avoid render props.react-hook-formでも<Controller/>を使ったらrender propsを使うことになるし，render propsから完全に逃れることはできないのではないか？とのことです。まとめ今回はReact Final Formを推奨とする結論になりましたが，「とにかく速く開発したいからみんなが使えて学習コストの低いreact hook formで」など，プロジェクトによって吟味する必要がありそうです。「react-hook-formは広く使われているからみんな慣れてるだろうし良い」というような意見に対して「学習コストが低いものを選定基準にするのではなく，既存のプロジェクトをBlitzに置き換えることになったときになるべく痛みが少ないものを使いたい。」と返していて，ライブラリ選定の参考になる見方だと思いました。追記React Hook Formの作者である@bluebill1049さんがコメントしてくださりました。(詳しくは本人のコメントを参照してください！)2020年12月ごろにリリースされたv6.13.0でuseControllerというhooksが追加されました。それを使えば<Controller>で囲ってRender propを使うという必要がなくなります。Material UIのコンポーネントなどを使う場合は<Controller>を使うしかありませんが，自作のコンポーネントを使う場合はuseControllerが使えます！また，refについてもV7ではフォーカス管理を改善していく予定とのことです。",
    "link": "https://qiita.com/marin_a__/items/eee408c5e99d5b53416e",
    "isoDate": "2021-01-06T06:48:03.000Z",
    "dateMiliSeconds": 1609915683000,
    "sourceType": "qiita"
  },
  {
    "title": "ExpoのOTA updateの仕様について",
    "contentSnippet": "この記事は React Native アドベントカレンダーの24日目の記事です。ExpoのOTA updateの仕様が分かりづらく，はまりどころが多いので，注意点や自分でアレンジする方法をまとめました。 OTA updateとはOver The Air updateの略。App Store(またはGoogle Play)からアップデートしなくても最新のバージョンに更新できます。審査を通す必要がないので素早く最新のバージョンをユーザーに届けることができます。 OTA updateのやりかた$ expo publishたったこれだけです。 release-channe...",
    "link": "https://zenn.dev/marin_a___/articles/7eec197a8c3579",
    "isoDate": "2020-12-24T03:33:21.000Z",
    "dateMiliSeconds": 1608780801000,
    "sourceType": "zenn"
  },
  {
    "title": "Apollo Client × codegen でのLocalStateの使い方",
    "contentSnippet": "この記事は GraphQL Advent Calendar 2020 19日目の記事です。前回の記事は @policeman-kh さんの GraphQLサーバーをJavaで実装してみる でした。Apollo ClientのLocal Stateとは公式ドキュメントローカルのデータをApollo Clientに保持しておくことができる仕組みです。GraphAPIからデータを取得する際に，同時にローカルのデータも取得することができるというメリットがあります。また，Reduxなどの状態管理ライブラリの代替的な役割としても使用できます。やりたいこと以下のようなDBが既に存在するとします。今回，users.idをactiveUserIdとしてLocal Stateに保持する方法を考えます。今回使用した環境ReactApollo ClientGraphQL Code Generatorhasuraqueryやmutationは既に動く状態で，Local Stateを追加することを想定します。補足：hasuraとはPostgreSQLからGraphQL APIサーバーを自動で構築してくれるものです。Postgreのデータベースに格納したデータに対してGraphQLのクエリが発行できるようになります。codegenの設定公式ドキュメントLocal Stateを利用する際，GraphQLサーバー側のschemaには存在しないフィールドやカラムをclient-side schemaに自分で追加していく流れになります。なので，まずはcodegenがclient-side schemaを認識するために，codegenの設定ファイルにschemaのパスを追加します。codegen.jsmodule.exports = {  schema: [      \"http://localhost:8080/v1/graphql\",      \"src/graphql/local-schema.graphql\", //追加  ],client-side schemaの書き方client-side schemaに以下のように書くことでactiveUserIdというフィールドをqueryに追加することができます。src/graphql/local-schema.graphqlextend type Query {  activeUserId: Int!}これを以下のように使用することができます。src/graphql/queries/MyArticles.graphqlquery MyArticles($id: Int!) {  activeUserId @client @export(as: \"id\")  user: users_by_pk(id: $id) {    id    name    articles {      id      body    }  }}@clientの箇所は，「キャッシュされているactiveUserIdを使用する」ということです。@export(as: \"id\")によって，activeUserIdを$idとしてusers_by_pkの引数に渡すことができます。その結果，useQueryを使うときにわざわざactiveUserIdを渡す必要がなくなります。const { data } = useMyArticlesQuery();また，console.log(data?.activeUserId);という形でキャッシュされたactiveUserIdを取得することもできます。※hasuraでの注意点hasuraでは上記のlocal-schema.graphqlの書き方ではエラーが出ます。 AggregateError:         GraphQLDocumentError: Cannot query field \"activeUserId\" on type \"query_root\".extend type Queryの代わりに以下のように書くことで解決しました。src/graphql/local-schema.graphqltype query_root {  activeUserId: Int!}Local Stateの値を操作するclient.writeQueryを利用します。    await client.writeQuery({      query: MyArticlesDocument,      data: { activeUserId: 1 },    });とすることで，MyArticles queryのacitveUserIdを1に書き換えることができます。注意点として，今回はquery単位でのキャッシュフィールド単位でのキャッシュの両方更新されるので，他のqueryでactiveUserIdを使用している場合，そちらのキャッシュも自動的に更新されます。(キャッシュについてはGraphQL Advent Calendar 2020 2日目で詳しく触れているのでぜひ参考にしてください。)補足以前はclient.writeData(またはcache.writeData)というメソッドがありました。しかし，公式にある通り，v3.0で廃止されています。client|cache.writeData have been fully removed. client|cache.writeQuery, client|cache.writeFragment, and/or cache.modify can be used to update the cache.PRによると，cache.writeDataを呼ぶと全てのqueryを実行し直すため，非効率的だったそうです。まとめReduxなどを使わずに，Apolloだけでremoteのデータもlocalのデータも一元管理することを目的としてLocal Stateが導入されたそうです。(参考：https://www.apollographql.com/blog/the-future-of-state-management-dd410864cae2/)Historically, Apollo users managed that 20% in a separate Redux or MobX store. This was a doable solution for Apollo Client 1.0, but when Apollo Client 2.0 migrated away from Redux, syncing local and remote data between two stores became trickier. We often heard from our users that they wanted to encapsulate all of their application’s state inside Apollo Client and maintain one source of truth.今回は「activeUserIdをLocalStateにいれることでqueryを簡単に使用できるようにする」という目的で使ってみましたが，もし単に状態管理をしたいだけであれば，Apollo Client v3.0での新機能のreactive variablesを使うのが良さそうです。使ってみたらまた記事に書こうと思っています。",
    "link": "https://qiita.com/marin_a__/items/9f47bf04ddc44aec4247",
    "isoDate": "2020-12-19T15:39:48.000Z",
    "dateMiliSeconds": 1608392388000,
    "sourceType": "qiita"
  },
  {
    "title": "TypeScript: 配列の長さを宣言する",
    "contentSnippet": "やりたいことconst numbers = [1, 2, 4, 5] as constconst foo = ['f', 'o', 'o'] as constlet numbers_len1: Length<typeof numbers> = 4; //OKlet numbers_len2: Length<typeof numbers> = 5; //エラーlet foo_len1: Length<typeof numbers> = 3; //OKlet foo_len2: Length<typeof numbers> = 4; //エラーとなるように，配列の長さを宣言するLength typeを作りたい。結論解決法１type Length<T extends ReadonlyArray<any>> = T['length']解決法２type Length<T extends readonly any[]> = T['length']解決法３type Length<T extends any> = T extends { length : infer R } ? R : never;解説すべてGenericsを使っています。ジェネリクスに関しては色んな方が分かりやすい記事をあげているのでそちらを参考にしてください。https://qiita.com/uhyo/items/e2fdef2d3236b9bfe74a#%E3%82%B8%E3%82%A7%E3%83%8D%E3%83%AA%E3%82%AF%E3%82%B9解決法１type Length<T extends ReadonlyArray<any>> = T['length']ReadonlyArrayという型がTypeScriptに用意されています。The ReadonlyArray type describes Arrays that can only be read fromfunction foo(arr: ReadonlyArray<string>) {  arr.slice(); // okay  arr.push(\"hello!\"); // error!}名前の通り，配列を変更するようなメソッドは使えませんが，今回のようにlengthを取得することはできます。解決法２type Length<T extends readonly any[]> = T['length']解決法１とほぼ同じです。今回は配列をas constでreadonlyとしているので，type Length<T extends any[]> = T['length'] とすると以下のエラーが発生してしまうので注意してください。The type 'readonly [1, 2, 4, 5]' is 'readonly' and cannot be assigned to the mutable type 'any[]'.解決法３type Length<T extends any> = T extends { length : infer R } ? R : never;inferについてはこちらの記事が分かりやすいです。T.lengthが存在する場合はそのlengthを返し，存在しない場合はneverを返しています。補足TypeChallengeというサイトに問題がたくさん載っていて，その中のLength of Tupleという問題になっています。上記以外にもたくさん解答があるので参考にしてください。https://github.com/type-challenges/type-challenges/issues?q=label%3A18+label%3Aanswer",
    "link": "https://qiita.com/marin_a__/items/74e087e8952dc78fe13e",
    "isoDate": "2020-11-29T15:19:05.000Z",
    "dateMiliSeconds": 1606663145000,
    "sourceType": "qiita"
  }
]
