[{"title":"Blitz.jsの議論から学ぶ，formik vs react-final-form vs react-hook-form","contentSnippet":"What should the default form library be in Blitz apps?Blitzがどのライブラリをデフォルトのformにするかの議論が参考になったので要約しました。formikreact-final-formreact-hook-formの３択で，結論としては，React Final Formを推奨とする形に落ち着きました。最初のコメントBlitz.jsの作者であるBrandon(@flybayer)さんがコメントしています。要約するとこんな感じ。FormikReact-final-formReact-hook-formReact-final-formをReact-hook-formに書き換えてみたが，コードの長さとしてはそこまで差異はない。https://github.com/blitz-js/blitz/pull/767/files議論全体的にFormikは無いよねという感じでした。気になった意見をpick upします。react-hook-formのデメリット対象のコメント→ https://github.com/blitz-js/blitz/discussions/768#discussioncomment-39148別のFromライブラリとの互換性の低さMaterialUIなどのサードパーティー製のコンポーネントと一緒に使う場合は<Controller>コンポーネントでwrapしなくてはいけない。      <Controller        name=\"iceCreamType\"        as={Select}        options={[          { value: \"chocolate\", label: \"Chocolate\" },          { value: \"strawberry\", label: \"Strawberry\" },          { value: \"vanilla\", label: \"Vanilla\" }        ]}        control={control}        rules={{ required: true }}      /><Controller>を使わないパターン(registerだけ使うパターン)と<Controller>を使うパターンの２つの異なるAPIを知っておかなくてはいけない。一方，react-final-formはuseField()というAPIだけで済むので，他のライブラリとの互換性が高い。refの渡し方が不自然focusしたときに何かを発動したいときなどはrefを自分で渡すことになるが，そのときのrefの渡し方が面倒くさい。  const { register, handleSubmit } = useForm();  const firstNameRef = useRef();  const onSubmit = data => console.log(data);  return (    <form onSubmit={handleSubmit(onSubmit)}>      <input name=\"firstName\" ref={(e) => {        register(e)              // hook-form register        firstNameRef.current = e // manually assign your ref      }} />ref={ref}で渡したいのに…。react-final-formのデメリットrender propsが初心者には難しいのではないか？というコメントがいくつかあった。基本的にrender propsを使うreact-final-formformik基本的にrender propsを使わないreact-hook-formそれに対し，Brandonさんは以下のように反論しています。there is only one top level render prop with final-form which also provides the form context.トップ層でしか使用していないし，So either way, you'll likely have a render prop. I definitely agree the primary API shouldn't be a render prop, but looks like it's impossible to 100% avoid render props.react-hook-formでも<Controller/>を使ったらrender propsを使うことになるし，render propsから完全に逃れることはできないのではないか？とのことです。まとめ「react-hook-formは広く使われているからみんな慣れてるだろうし良い」というような意見に対して「学習コストが低いものを選定基準にするのではなく，既存のプロジェクトをBlitzに置き換えることになったときになるべく痛みが少ないものを使いたい。」と返していて，ライブラリ選定の参考になる見方だと思いました。","link":"https://qiita.com/marin_a__/items/eee408c5e99d5b53416e","isoDate":"2021-01-06T06:48:03.000Z","dateMiliSeconds":1609915683000,"sourceType":"qiita"},{"title":"ExpoのOTA updateの仕様について","contentSnippet":"この記事は React Native アドベントカレンダーの24日目の記事です。ExpoのOTA updateの仕様が分かりづらく，はまりどころが多いので，注意点や自分でアレンジする方法をまとめました。OTA updateとはOver The Air updateの略。App Store(またはGoogle Play)からアップデートしなくても最新のバージョンに更新できます。審査を通す必要がないので素早く最新のバージョンをユーザーに届けることができます。OTA updateのやりかた                      $ expo publish    ...","link":"https://zenn.dev/marin_a___/articles/7eec197a8c3579","isoDate":"2020-12-24T03:33:21.000Z","dateMiliSeconds":1608780801000,"sourceType":"zenn"},{"title":"Apollo Client × codegen でのLocalStateの使い方","contentSnippet":"この記事は GraphQL Advent Calendar 2020 19日目の記事です。@policeman-kh さんの GraphQLサーバーをJavaで実装してみる でした。Apollo ClientのLocal Stateとは公式ドキュメントローカルのデータをApollo Clientに保持しておくことができる仕組みです。GraphAPIからデータを取得する際に，同時にローカルのデータも取得することができるというメリットがあります。また，Reduxなどの状態管理ライブラリの代替的な役割としても使用できます。やりたいこと以下のようなDBが既に存在するとします。今回，users.idをactiveUserIdとしてLocal Stateに保持する方法を考えます。今回使用した環境ReactApollo ClientGraphQL Code Generatorhasuraqueryやmutationは既に動く状態で，Local Stateを追加することを想定します。補足：hasuraとはPostgreSQLからGraphQL APIサーバーを自動で構築してくれるものです。Postgreのデータベースに格納したデータに対してGraphQLのクエリが発行できるようになります。codegenの設定公式ドキュメントcodegen.jsmodule.exports = {  schema: [      \"http://localhost:8080/v1/graphql\",      \"src/graphql/local-schema.graphql\", //追加  ],https://github.com/marina-ki/apollo-client_local-state/blob/main/packages/web/codegen.jsclient-side schemaの書き方client-side schemaに以下のように書くことでactiveUserIdというフィールドをqueryに追加することができます。src/graphql/local-schema.graphqlextend type Query {  activeUserId: Int!}これを以下のように使用することができます。src/graphql/queries/MyArticles.graphqlquery MyArticles($id: Int!) {  activeUserId @client @export(as: \"id\")  user: users_by_pk(id: $id) {    id    name    articles {      id      body    }  }}@clientの箇所は，「キャッシュされているactiveUserIdを使用する」ということです。@export(as: \"id\")によって，activeUserIdを$idとしてusers_by_pkの引数に渡すことができます。その結果，useQueryを使うときにわざわざactiveUserIdを渡す必要がなくなります。const { data } = useMyArticlesQuery();また，console.log(data?.activeUserId);という形でキャッシュされたactiveUserIdを取得することもできます。※hasuraでの注意点hasuraでは上記のlocal-schema.graphqlの書き方ではエラーが出ます。 AggregateError:         GraphQLDocumentError: Cannot query field \"activeUserId\" on type \"query_root\".extend type Queryの代わりに以下のように書くことで解決しました。src/graphql/local-schema.graphqltype query_root {  activeUserId: Int!}Local Stateの値を操作するclient.writeQueryを利用します。    await client.writeQuery({      query: MyArticlesDocument,      data: { activeUserId: 1 },    });とすることで，MyArticles queryのacitveUserIdを1に書き換えることができます。注意点として，今回はquery単位でのキャッシュフィールド単位でのキャッシュの両方更新されるので，他のqueryでactiveUserIdを使用している場合，そちらのキャッシュも自動的に更新されます。(キャッシュについてはGraphQL Advent Calendar 2020 2日目で詳しく触れているのでぜひ参考にしてください。)補足以前はclient.writeData(またはcache.writeData)というメソッドがありました。しかし，公式にある通り，v3.0で廃止されています。client|cache.writeData have been fully removed. client|cache.writeQuery, client|cache.writeFragment, and/or cache.modify can be used to update the cache.PRによると，cache.writeDataを呼ぶと全てのqueryを実行し直すため，非効率的だったそうです。まとめReduxなどを使わずに，Apolloだけでremoteのデータもlocalのデータも一元管理することを目的としてLocal Stateが導入されたそうです。https://www.apollographql.com/blog/the-future-of-state-management-dd410864cae2/)Historically, Apollo users managed that 20% in a separate Redux or MobX store. This was a doable solution for Apollo Client 1.0, but when Apollo Client 2.0 migrated away from Redux, syncing local and remote data between two stores became trickier. We often heard from our users that they wanted to encapsulate all of their application’s state inside Apollo Client and maintain one source of truth.今回は「activeUserIdをLocalStateにいれることでqueryを簡単に使用できるようにする」という目的で使ってみましたが，もし単に状態管理をしたいだけであれば，Apollo Client v3.0での新機能のreactive variablesを使うのが良さそうです。使ってみたらまた記事に書こうと思っています。","link":"https://qiita.com/marin_a__/items/9f47bf04ddc44aec4247","isoDate":"2020-12-19T15:39:48.000Z","dateMiliSeconds":1608392388000,"sourceType":"qiita"},{"title":"TypeScript: 配列の長さを宣言する","contentSnippet":"やりたいことconst numbers = [1, 2, 4, 5] as constconst foo = ['f', 'o', 'o'] as constlet numbers_len1: Length<typeof numbers> = 4; //OKlet numbers_len2: Length<typeof numbers> = 5; //エラーlet foo_len1: Length<typeof numbers> = 3; //OKlet foo_len2: Length<typeof numbers> = 4; //エラーとなるように，配列の長さを宣言するLength typeを作りたい。結論解決法１type Length<T extends ReadonlyArray<any>> = T['length']解決法２type Length<T extends readonly any[]> = T['length']解決法３type Length<T extends any> = T extends { length : infer R } ? R : never;解説すべてGenericsを使っています。https://qiita.com/uhyo/items/e2fdef2d3236b9bfe74a#%E3%82%B8%E3%82%A7%E3%83%8D%E3%83%AA%E3%82%AF%E3%82%B9解決法１type Length<T extends ReadonlyArray<any>> = T['length']ReadonlyArrayという型がTypeScriptに用意されています。The ReadonlyArray type describes Arrays that can only be read fromfunction foo(arr: ReadonlyArray<string>) {  arr.slice(); // okay  arr.push(\"hello!\"); // error!}名前の通り，配列を変更するようなメソッドは使えませんが，今回のようにlengthを取得することはできます。解決法２type Length<T extends readonly any[]> = T['length']解決法１とほぼ同じです。今回は配列をas constでreadonlyとしているので，type Length<T extends any[]> = T['length'] The type 'readonly [1, 2, 4, 5]' is 'readonly' and cannot be assigned to the mutable type 'any[]'.解決法３type Length<T extends any> = T extends { length : infer R } ? R : never;inferについてはこちらの記事が分かりやすいです。T.lengthが存在する場合はそのlengthを返し，存在しない場合はneverを返しています。補足TypeChallengeというサイトに問題がたくさん載っていて，その中のLength of Tupleという問題になっています。上記以外にもたくさん解答があるので参考にしてください。https://github.com/type-challenges/type-challenges/issues?q=label%3A18+label%3Aanswer","link":"https://qiita.com/marin_a__/items/74e087e8952dc78fe13e","isoDate":"2020-11-29T15:19:05.000Z","dateMiliSeconds":1606663145000,"sourceType":"qiita"}]
